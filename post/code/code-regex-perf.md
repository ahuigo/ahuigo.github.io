---
title:	正则性能优化
date: 2018-08-18
---
# 回溯优化
鸟哥有一个示例：

    $reg = "/<script>.*?<\/script>/is";
    $str = "at:<script>********".str_repeat("*", 1e6)."</script>end";
    echo preg_repalce($reg, "", $str); //返回NULL 其原因就是回溯太多了，直到造成耗尽栈空间爆栈(？)

对于字符串：

	<script>123456</script>
  
对于以下表达式的回溯次数分别为：

    /<script>.+<\/script>/;    //9次=len(</script>)     (无法匹配</script>就会反向回溯)
    /<script>.+?<\/script>/;  //5次=len(23456)  (无法匹配</script>就会正向回溯)
    /<script>(?:(?!<\/script>).)+<\/script>/;  //7次=len(123456<) 走到`<` 时，才通过匹配

如果中间不允许有字符`<` 可优化为如下，不过依然没有避免回溯的问题：
	
	/<script>[^<]*<\/script>/is         //如果匹配不到后面的, 就会反向回溯 `[^<]*`
	/<script>[^<]*?<\/script>/is         //如果匹配不到后面的, 就会正向回溯 `[^<]*?`

避免回溯可以用下面固化分组来优化:

	/<script>(?>[^<]*)<\/script>/is         //如果匹配不到后面的, 不会回溯

## 固化分组`(?>expr)`
> 使用`(?>expr)`固化分组匹配，固化为一个单元，匹配失败不会回溯，直接放弃

比如只要匹配`[1-3]`匹配成功后，即使后面的匹配失败，也不会回溯:

    '3a'.match(/(?>[1-3]?)\d+/) //failed

对于js/python/go 来说，是不支持固化的，替代的做法是利用环视

    用 (?=(expr))\1 代替 (?>expr) 
    '3a'.match(/(?=([1-3]?))\1\d+/) //failed
    '3a'.match(/(?=([0-3]?))\1\d+/)

利用非回溯子表达式`?>`, 栖草改写的鸟哥的表达式所写的正则[php正则效率:回溯]

	/<script>(?>[^<]*)(?>(?!</?script>)<[^<]*)*</script>/

    # 解释 一下
	/<script>
    固化1 (?>[^<]*)   非<
    固化2 (?> (?!</?script>) <[^<]*)*  <符
    </script>/

js测试一下, js 不支持固化：

    > '<script>a<script></script>end'.match(/<script>([^<]*)((?!<\/?script>)<[^<]*)*<\/script>/)
    [ "<script></script>", "", undefined ]
    > '<script>a<script ></script>end'.match(/<script>([^<]*)((?!<\/?script>)<[^<]*)*<\/script>/)
    [ "<script>a<script ></script>", "a", "<script >" ]

## 嵌套回溯优化
先看看：

    // 1层回溯
    `${' '.repeat(10000)}x`.search(/^ *$/)    // 复杂度: 10000+反向回溯10000 = 2*n = O(2n) = O(n)

    //2层嵌套回溯
    `${' '.repeat(100000)}x`.search(/^ * *$/) // 复杂度: 10000+反向回溯(2+4+...+2n) = O(n^2)
    `${' '.repeat(100000)}x`.search(/^ *\n? *$/)    // 同上

    //3层嵌套回溯
    `${' '.repeat(1000)}x${' '.repeat(1000)}x`.search(/^ *\n? *$/)    // 同上

对于多层嵌套回溯来说， 可通过构造不能匹配的特定字符, 中断子组回溯:

    // 两层嵌套回溯: 包含一个可选换行
    `${' '.repeat(1000)}x`.search(/^ *\n? *$/)    

    // 改进：由于子组中`\n`匹配不成功，子组提前中断，不会回溯
    `${' '.repeat(1000)}x`.search(/^ *(\n *)?$/)   

在`marked.js`中就有这样一段代码: https://github.com/markedjs/marked/commit/c4a3ccd344b6929afa8a1d50ac54a721e57012c0

    let badregx= /^ {0,3}\[((?!\s*\])(?:\\.|[^\[\]\\])+)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)((?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))))? *(?:\n+|$)/

    # 改进：构造不能匹配的特定字符: `(?:\n *)?`
    let goodregx= /^ {0,3}\[((?!\s*\])(?:\\.|[^\[\]\\])+)\]: *(?:\n *)?<?([^\s>]+)>?(?:(?: +(?:\n *)?| *\n *)((?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))))? *(?:\n+|$)/

    `${' '.repeat(1000)}x${' '.repeat(1000)}x`.search(badregx)

上面的这个`badregx` 执行匹配时的最坏算法复杂度为`O(n^3)`:

    let badregx=/a/g
    let ts=`${' '.repeat(1000)}x${' '.repeat(1000)}x`
    badregx= /^ *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)((?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))))? *(?:\n+|$)/
    badregx= /^ *\n? *([^\s>]+)(?:(?: +\n? *| *\n *)((?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))))? *(?:\n+|$)/
    badregx= /^ *\n? *x(?:(?: +\n? *| *\n *)((?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))))? *$/
    badregx= /^ * *x(?:(?: +\n? *| *\n *)(?:"|'*'|\([^()]*\)))? *$/
    badregx= /^ + *x(( +\n? *| *\n *)a)? *$/ 
    // 可以看到上面这一行: 分左右两部
    // 1. 左边这一部分 ` + *x` 看起来是`n^2`双层回溯. 实际执行时只有` +`一层回溯, 因为` *x`匹配成功后不会回溯，复杂度为 `O(n)`
    // 2. 由于匹配到x会成功，先不回溯第一部分，会先匹配右边的`(( +\n? *| *\n *)a)? *` 
    // 3. 右边的部分，分内两层回溯`(( +\n? *| *\n *)a)?`+外一层回溯` *$`
    //      3.1 内层无法匹配a， 所以会执行两层回溯:`(( +\n? *| *\n *)a)?`, 复杂度为n^2
    //      3.2 再执行外一层, 无法匹配$， 会执行一层回溯: ` *$`, 复杂度为n
    //      3.2 右侧这层复杂度为n^2+n, 而且无法匹配成功
    //  4. 左边部分开始执行回溯匹配：上面说了，左侧执行回溯复杂度是O(n)
    //      4.1 每次回溯会匹配到x成功后，会执行右侧匹配
    //  5. 左右两层嵌套，总体复杂度为：O(n) + O(n^2+n) = O(n^3)
    badregx= /^ + *x(( +\n? *| *\n *)a)?$/ 
    badregx= /^ + *x(( +\n? *| *)a)?$/ 
    badregx= /^ + *x(( +\n? *)a)$/ 
    badregx= /^ + *x( +\n? *)$/ 
    badregx= /^ + *x + *$/ 
    badregx= /^ + *x * *$/ 
    badregx.test(ts)

# Reference
- [php正则效率:回溯]

[php正则效率:回溯]: http://www.cnxct.com/php%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%95%88%E7%8E%87%EF%BC%9A%E5%9B%9E%E6%BA%AF%E4%B8%8E%E5%9B%BA%E5%8C%96%E5%88%86%E7%BB%84/
