---
layout: page
title: c-mem
category: blog
description: 
date: 2018-09-27
---
# swap
内存足够的情况下 不需要 swap

    临时： swapoff /dev/sdax  （swapoff -a 关闭）
    永久： /etc/fstab 将 swap 的注释掉或者设置为0，重启后或者 mount -a 生效

# Linux内存管理中的分段和分页技术。
从虚拟地址映射到物理地址，有分段和分页两种技术
## 分段(Segmentation)
这个映射过程由软件来设置映射的机制，实际的转换由硬件 MMU(Memory Management Unit)来完成:

    段寄存器（段基地址）+ 虚拟地址 = 物理地址

## 分页
分页是把内存分为若干个很小的固定大小的页，Linux中一般页的大小是4KB. 可通过命令查看`getconf PAGE_SIZE`
1. 分页可避免分配释放大内存浪费( 就像Linux中的Buddy算法和slab内存分配机制）
2. 分页方便细精度的内在共享, 线程间内存共享需要互斥锁`pthread_mutex_init(互斥锁地址， 属性对象地址)`
2. 大内存可分配到不连续的分页物理内存

# 内存的管理
2. 内存管理主要分为内核的内存管理以及进程（用户空间）的内存管理
3. 进程的内存管理：（小内存brk实现，大内存mmap实现）
    1）进程所使用的内存是虚拟地址，并不是直接的物理内存，中间需要一定的机制进行映射，这里不讨论映射机制，了解即可。
    2）每个进程需要用到内存的主要有text、data、bss、heap、stack，就是一些程序、变量等，主要分两类，静态分配的关于变量等，动态分配的使用heap的，这里主要学习动态分配的heap（堆）。（静态分配会自动释放，动态分配要手工free释放）
    3）进程如何动态分配内存：使用malloc（）函数，就可以取得内存。
    4）虚拟地址与物理地址：进程通过malloc（）获得的只是虚拟地址空间，并未实际占用物理内存，直到真正使用的时候才进行地址映射，取得物理内存的空间。
    5）malloc细节：glibc的函数maloc通过系统调用brk（）或mmap（）来分配内存。
         小块内存（<=128kbytes），使用brk（）
         大块内存（>128kbytes），使用mmap（）
    6）brk（）：是堆机制，内存分配一直往上堆，尽量先从现有的堆中分配，没有的话，通过brk（）增大堆。这里涉及如何分配的各种算法，这里不讨论。
    7）mmap（）：大块内存的时候申请。
    8）重点_brk()的free：如果是通过brk（）申请的空间，使用free（）释放后，并不会马上释放给系统，而是释放给glibc管理器统一分配协调。glibc是通过查看堆顶的连续空间是否有大于一定的值，如果有的话，才进行释放，否则不释放。
   例子：如果进程申请了10块堆的空间，其中9块已经释放了，有1块在离堆顶最近的地方但是没有释放，那么这十块就都没有办法释放。
   9）mmap（）的free：mmap会直接free掉，不会出现brk（）的问题。
4. 内核的内存管理：通过slab机制，主要解决小内存的问题。
    1）内核的内存主要有对象和控制结构使用。
    2）slab为内核中常用的对象建立专门的对象池，比如task结构的池。
    3）维护通用的对象池，比如32字节大小的对象池
    4）控制结构有两种方式，如果控制结构较大，使用专门的页面，如果较小，使用对象池。
5. 内存管理的缓存：内存中会有一部内存被暂时保存，以便下次调用的时候不需要重新分配和初始化，主要有cache和buffer两种类型。只有等到系统内存不够的时候，
可以用cache和buffer中的内存，所以可以这里理解cache和buffer：是已经分配但是当前不可用的内存，当系统内存不足的时候可以用。
6. free命令：
    1. buffers和cached就是已经分配，但是还未用的。
    2. Mem：这一行的used就是包括buffer/cache的，free就是当前目前马上可用的。
    3. used是不包括buffer/cache的，就是实际使用的，free是包括buffer和cache的。