---
title: GC
date: 2018-09-27
---
# GC
## 引用计数垃圾收集
最简单的垃圾收集算法
### 限制：循环引用
该算法有个限制：无法处理循环引用。
1. o1, o2 在函数销毁后，计数从2变1
2. 计数1：o1,o2 相互引用，相互需要。但是实际不被别人需要
3. 改进-循环检测：
    1. 从`o1 = o2.a <- o2 = o1.a <- o1` 发生循环`o1=o2.a减一` 变零`销毁o1`，
    2. `销毁o1`-`销毁o1.a` 导致`o2`减去1， `o2`被销毁

recycle counter:

    function f(){
        var o1 = {};
        var o2 = {};
        o1.a = o2; // o1 引用 o2
        o2.a = o1; // o2 引用 o1
    }

    f();

# 标记-清除算法(Mark-And-Sweeping)
这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。定期的，垃圾回收器将从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。

这个算法是严格按照追踪式算法的思路来实现的。这个算法会设置一个标志位来记录对象是否被使用。最开始所有的标记位都是0，如果发现对象是可达的就会置为1，一步步下去就会呈现一个类似树状的结果。等标记的步骤完成后，会将未标记的对象统一清理，再次把所有标记位设置成0方便下次清理。

这个算法比前一个要好，因为“有零引用的对象”总是不可获得的，但是相反却不一定，参考“循环引用”。

从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。
## stop the world
这个算法最大的问题是GC执行期间需要把整个程序完全暂停，不能异步进行GC操作(新分配的内存可能还是标记0, 会被清理)。
所以就需要一个算法来解决GC运行时程序长时间挂起的问题，就是三色标记算法

## 三色标记法(golang)
三色标记法是对“标记”阶段的改进, 减少了STW, 它将变量标记为：白色(未搜索的)、灰色(正在搜索)、黑色(搜索完成).
1. 最开始所有对象都是白色的，然后把其中全局变量和函数栈里的对象置为灰色。
2. 第二步把灰色对象全部置为黑色，然后把原先灰色对象指向的变量都置为灰色，以此类推。
3. 等发现没有对象可以被置为灰色时，所有的白色变量就一定是需要被清理的垃圾了。

三色标记法因为多了一个白色的状态来存放不确定的对象，所以可以异步地执行。

一次完整的垃圾回 
### 阶段一：Mark Setup 标记灰色
**此阶段gc和goroutine 会并发的运行**，为了防止新分配的内存没有标记到被意外回收。 这个时候会打开Write Barrier(写屏障)？
> Write Barrier修改了原先写的逻辑, 在运行过程中程序的函数栈可能会有新分配的对象，新增的同时给它着色，并且着色为“灰色”

在打开Write Barrier前有一个依赖，我们需要先停止所有的goroutine，也就是STW操作, GC会通知所有的goroutine停止:

在停止goroutine的方案中，Go语言采取的是合作式抢占模式。这种模式的做法是在程序编译阶段注入额外的代码，更精确的说法是在每个函数序言中增加一个合作式抢占点。因为一个goroutine中通常有无数调用函数的操作，选择在函数序言中增加抢占点可以较好地平衡性能和实时性之间点利弊。在通常情况下，一次Mark Setup会在10～30微秒之间。

### 阶段二：Marking 标记 （Concurrent）
将灰色改成黑色, 被灰色引用的变量如果是白色改成灰色。

### 阶段三：Mark Termination 标记结束
最重要的Marking阶段结束后就会进入Mark Termination阶段。这个阶段会关闭掉已经打开的Write Barrier，和Mark Setup阶段一样这个阶段也需要STW。

通常情况下，标记结束阶段会耗时60～90微秒。

### 阶段四：Sweeping 清除 （Concurrent）
最后一个阶段就是垃圾清理阶段，这个过程是并发进行的。

# 分代回收法(java)
按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，短的放入新生代，不同代有不同的回收算法和回收频率。

代表语言：Java
优点：回收性能好
缺点：算法复杂

# golang gc
链接：https://zhuanlan.zhihu.com/p/77943973
1. 1.3以前的版本使用标记-清理的方式，整个过程都需要STW。
1. 1.3版本分离了标记和清理的操作，标记过程STW，清理过程并发执行。
1. 1.5版本在标记过程中使用三色标记法。回收过程主要有四个阶段，其中，标记和清理都并发执行的，但标记阶段的前后需要STW一定时间来做GC的准备工作和栈的re-scan。
1. 1.8版本在引入混合屏障rescan来降低mark termination的时间


# Rerference
1. https://developer.aliyun.com/article/775798
1. golang垃圾回收机制: https://www.hurace.net/post/golang-gc/
