---
title: 死锁
date: 2020-04-29
private: true
---
# 死锁
## 死锁发生
1. 线程A获得了锁1,线程B获得了锁2,
2. 这时线程A调用lock试图获得锁2,结果是需要挂起等待线程B释放锁2,
3. 而这时线程B也调用lock试图获得锁1,结果是需要挂起等待线程A释放锁1
4. 于是线程A和B都在等待对方释放自己才释放，从而造成两个都永远处于挂起状态，造成死锁。

## 避免死锁
几个方法
1. 保证加锁的顺序：所有线程在需要同时获得2个或3个锁时都应该按锁1、锁2、锁3的顺序获得
2. 避免死锁的银行家算法

### 银行家算法
1. 每一个线程进入系统时，它必须声明: 运行所需的`每种资源类型最大数目`，其数目不应超过系统所拥有每种资源总量
2. 当线程请求一组资源系统必须确定有足够资源分配给该进程，若有在进一步计算这些资源分配给进程后，是否会使系统处于不安全状态，不会（即若能在分配资源时找到一个安全序列），则将资源分配给它，否则等待。

## 检测死锁
2. 锁超时: lock 超时判断为死锁
3. 检测死锁：循环检测

# 自旋锁（Spinlock）

自旋锁（Spinlock） 是一种同步机制，用于保护对共享资源的并发访问。当一个线程尝试获取一个已经被其他线程持有的自旋锁时，该线程将在一个循环中不断检查锁是否可用，这个过程被称为"自旋"。这意味着线程会忙等待，直到它能够获取锁。

自旋锁适用于锁持有时间非常短的情况，因为它们避免了线程切换的开销。然而，如果预期锁持有时间较长，使用自旋锁可能会导致大量的CPU时间被浪费在自旋上，这在多线程环境中可能会导致性能问题

