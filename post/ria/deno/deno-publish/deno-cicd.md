---
title: deno cicd
date: 2022-07-11
private: true
---
# Preface
> https://deno.land/manual/continuous_integration
Let's set up basic pipelines for Deno projects in GitHub Actions

# github pipeline

```yml
name: Build

on: push

jobs:
  build:
    runs-on: ubuntu-20.04
    steps:
      - uses: actions/checkout@v3
      - uses: denoland/setup-deno@v1.0.0
        with:
          deno-version: v1.x # Run with latest stable Deno.
      # Check if the code is formatted according to Deno's default
      # formatting conventions.
      - run: deno fmt --check

      # Scan the code for syntax errors and style issues. If
      # you want to use a custom linter configuration you can add a configuration file with --config <myconfig>
      - run: deno lint

      # Run all test files in the repository and collect code coverage. The example
      # runs with all permissions, but it is recommended to run with the minimal permissions your program needs (for example --allow-read).
      - run: deno test --allow-all --coverage=cov/

      # This generates a report from the collected coverage in `deno test --coverage`. It is
      # stored as a .lcov file which integrates well with services such as Codecov, Coveralls and Travis CI.
      - run: deno coverage --lcov cov/ > cov.lcov
```

## Cross-platform workflows
A cross-platform workflow can be achieved by running a matrix of parallel jobs, each one running the build on a different OS:

```yaml
jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ ubuntu-20.04, macos-11, windows-2019 ]
    steps:
      - run: deno test --allow-all --coverage cov/
```

If you are working with `experimental or unstable` Deno APIs, you can include a matrix job running the canary version of Deno. 

This can help to spot breaking changes early on:

```yaml
jobs:
  build:
    runs-on: ${{ matrix.os }}
    continue-on-error: ${{ matrix.canary }} # Continue in case the canary run does not succeed
    strategy:
      matrix:
        os: [ ubuntu-20.04, macos-11, windows-2019 ]
        deno-version: [ v1.x ]
        canary: [ false ]
        include: 
          - deno-version: canary
            os: ubuntu-20.04
            canary: true
```

## condition step

```yaml
- name: Generate coverage report
  if: matrix.os == 'ubuntu-20.04'
  run: deno coverage --lcov cov > cov.lcov

- name: Upload coverage to Coveralls.io
  if: matrix.os == 'ubuntu-20.04'
  # Any code coverage service can be used, Coveralls.io is used here as an example.
  uses: coverallsapp/github-action@master
  with:
    github-token: ${{ secrets.GITHUB_TOKEN }} # Generated by GitHub.
    path-to-lcov: cov.lcov
```
## Caching dependencies
In a pipeline the cache can be preserved between workflows by setting the `DENO_DIR` environment variable and adding a caching step to the workflow:

    env:
      DENO_DIR: my_cache_directory

    steps:
      - name: Cache Deno dependencies 
        uses: actions/cache@v2
        with:
          path: ${{ env.DENO_DIR }}
          key: my_cache_key

if lock.json is updated, we want to update key:  using the hashFiles function provided by GitHub Actions

    key: ${{ hashFiles('lock.json') }}



# deploy
## deno deploy
## vercel deno runtime
https://github.com/vercel-community/deno

vercel bot for github
https://github.com/react-component/field-form/commit/d7892873e9eee6e4c618d4289fcdbc9ee240f68f