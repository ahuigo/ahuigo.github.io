---
title: golang gc
date: 2023-09-01
private: true
---
# gc 调优
## gc过程
> https://go.dev/doc/gc-guide#GOGC
gc分为两个阶段：stw+标记、清理

### 1.STW（标记准备阶段，Mark Setup: 开启写屏障）
触发时机: GC 开始时。
持续时间: 极短，通常在 10 到 100 微秒之间。
任务: 开启写屏障（Write Barrier）。
1. 扫描所有根对象（主要是全局变量和活跃 Goroutine 的栈）。注意，这里只会扫描栈，如果栈很大，扫描会交给并发标记阶段去做，以避免延长 STW。

然后: STW 结束，应用程序恢复运行，runtime.gcBgMarkWorker 开始并发标记。

### 2.并发标记阶段（Concurrent Marking, 并行）
活动主角: runtime.gcBgMarkWorker。
状态: 应用程序 Goroutine 和 GC worker 并行工作。

#### 三色标记法
- 白色 (White): 初始状态，潜在的垃圾。
- 灰色 (Gray): 已被标记为存活，但其引用的子对象尚未扫描。
- 黑色 (Black): 已被标记为存活，且其引用的所有子对象都已扫描完毕。

写屏障是为了防止遗漏任何新创建或修改的对象引用, 如下场景:
1. 对象 A 已经被 GC worker 扫描过了（变为黑色）。
2. 并发的应用程序 Goroutine 修改了对象 A，使其引用了一个新创建的对象 B（B 是白色的初始状态，因为还没有被扫描过）。

当你的程序执行 A.field = B (其中 A 是黑色，B 是白色) 时，写屏障会被触发:
1. 将新指向的对象 B “强制”变成灰色。相当于告诉 GC worker：“嘿，这个对象 B 是灰色活跃的，别忘了扫描它！先放待处理队列”
2. 后续 GC worker 会扫描灰色对象 B，将其标记为黑色，并继续扫描它引用的其他对象。


### 3. STW（标记终止阶段，Mark Termination：关闭写屏障）

触发时机: 当并发标记工作基本完成时。
持续时间: 比第一次长，但 Go 的目标是将其控制在毫秒级甚至更低。这通常是人们谈论 GC 暂停时最关心的部分。
任务:
禁用写屏障。
完成所有剩余的标记工作。这包括重新扫描那些在并发标记期间被修改过的对象，以及处理一些特殊情况。
然后: STW 结束，应用程序恢复运行，进入并发清扫阶段。
### 4. 并发清扫阶段（Concurrent Sweeping）
清理不需要 STW，应用程序继续运行。

## gc trace
开启 gc trace: GODEBUG="gctrace=1" ./bin/app

    日志行: gc 21 @785.135s 0%: 0.30+7163+0.13 ms clock, 9.6+17/57294/0+4.4 ms cpu, 31070->36934->29394 MB, 47101 MB goal, 0 MB stacks, 0 MB globals, 32 P


好的，这条 GC 日志与之前的截然不同，它揭示了一个 **非常严重** 的性能问题。

让我们直接看结论，然后再详细分析。

### 核心结论

这条日志表明你的应用程序正在经历一次 **持续时间极长（超过 7 秒）的并发 GC 阶段**，并且处理着 **巨大的内存（超过 30 GB）**。

*   **直接暂停时间 (STW) 依然很短**：`0.30ms + 0.13ms = 0.43ms`。你的应用程序并没有被“冻结”很长时间。
*   **但并发阶段是性能杀手**：GC 在后台疯狂地工作了 **7.163 秒** (`7163 ms`)。在这段时间里，GC 会与你的应用程序争夺 CPU 资源。
*   **CPU 资源被大量占用**：GC 在这 7.1 秒内消耗了 **57.294 秒** (`57294 ms`) 的 CPU 时间。在 32 核（32 P）的机器上，这相当于平均有 `57294 / 7163 ≈ 8` 个 CPU 核心被持续用于执行 GC 任务。

**所以，虽然程序没有被“暂停”，但它在这 7 秒内可能变得非常卡顿和缓慢。** 这完全可以解释为什么你的 `time.After(200ms)` 会延迟到 1 秒甚至更久——因为你的 Goroutine 和 Go 的计时器 Goroutine 都在和 GC 抢夺 CPU，根本排不上队。

---

### GC Trace 日志详解

解释一下gc日志行: `gc 21 @785.135s 0%: 0.30+7163+0.13 ms clock, 9.6+17/57294/0+4.4 ms cpu, 31070->36934->29394 MB, 47101 MB goal, 0 MB stacks, 0 MB globals, 32 P`

1. `gc 21`: 第 21 次 GC。
1. `@785.135s`:程序启动后约 13 分钟 (`785s`) 触发。 
1. `0%` : GC 总耗时占比。对于长时间运行的服务，这个平均值可能会掩盖单次 GC 的巨大影响。**不要被这个 0% 迷惑。** 
1. `ms clock`: `0.30+7163+0.13 ms`, 这是我们真实世界感知到的时间流逝
    - `0.30ms`: **STW** - 标记准备阶段。 (非常快)
    - `7163ms`: **并发标记与扫描**。**持续了 7.163 秒！** 在此期间，GC 与你的应用程序并发运行，争抢 CPU。
    - `0.13ms`: **STW** - 标记终止阶段。 (非常快)
    - **总 STW 暂停时间 = 0.43 毫秒。**<br> **但并发阶段耗时 = 7.163 秒！** 
1. `ms cpu` : `9.6+17/57294/0+4.4 ms`,`C1 + C2 / C3 / C4 + C5`  GC 各阶段消耗的 CPU 总时间。
    - c1 `9.6ms`: CPU 时间用于标记准备阶段 (STW)。
        - 说明有多个 CPU 核心 (9.6 / 0.30 ≈ 32 个) 参与了这个短暂的准备工作
    - c2 `17ms`: GC 辅助 (GC Assist) CPU 时间
        1. 当应用程序的 Goroutine 分配内存的速度太快，以至于 GC 感觉自己“快要跟不上了”，它就会强制这个正在分配内存的 Goroutine 停下来，帮 GC 干一会儿活。
        2. 这 17ms 就是你的应用程序 Goroutine 被“抓壮丁”去辅助 GC 的总 CPU 时间。这个值不为零，说明你的应用分配速率很高
    - c3 `57294ms`: 后台并发标记 (Background Concurrent Mark) CPU 时间
        1. Go 运行时会启动专门的后台 Goroutine 来执行并发标记任务, 这个时间太长了，说明 GC 在这段时间内非常忙碌。57s/7.163 ≈ 8 相当于有 8 个 CPU 核心被持续用于 GC 工作。
        - `57294ms`: GC worker 在此期间消耗的 CPU 时间。**这是一个巨大的数字！** 
    - c4 `0ms`: 空闲并发标记 (Idle Concurrent Mark) CPU 时间
        1. 如果系统处于空闲状态（没有用户 Goroutine 在运行），Go 会利用这些空闲的 CPU 来执行 GC 标记。
        2. 这个值为 0 意味着 在长达 7.1 秒的并发标记期间，你的系统从未有过片刻空闲。应用程序的 Goroutine 和 GC 的 Goroutine 一直在激烈地争抢 CPU 资源。
    - c5 `4.4ms`: 标记终止阶段 (STW) CPU 时间
        1. 说明有多个 CPU 核心 (4.4 / 0.13 ≈ 32 个) 参与了这个短暂的终止工作
1. `31070->36934->29394 MB`| **这说明内存使用量巨大且分配频繁。**
     - M1:`31070 MB`: GC 开始前的堆大小（约 31 GB）。
     - M2:`36934 MB`: GC 结束时的堆大小（约 37 GB）。**注意：这个值比开始时还大！** 这意味着在长达 7 秒的 GC 期间，你的应用程序又分配了约 6 GB 的新内存 (`37-31=6`)。
     - M3`29394 MB`: 标记结束清理后，存活的堆大小（约 29 GB）。
1. M4 goal: `47101 MB` 下一次 GC 的触发阈值（约 47 GB）。
1. `32 P` : 程序使用了 32 个逻辑核心。

从以上数据看出问题:
1.  **超大的内存堆（Heap）**：你的应用使用了数十 GB 的内存。扫描如此大的内存堆自然需要很长时间。
2.  **极高的内存分配速率（Allocation Rate）**：从 `31070 MB -> 36934 MB` 的变化可以看出，你的应用在 GC 运行时仍然在高速地创建新对象、分配新内存。

3.  **CPU 饥饿（Starvation）**：并发 GC 占用了大约 8 个 CPU 核心长达 7 秒。如果你的应用程序本身也是 CPU 密集型的，那么你的业务 Goroutine（包括处理 `time.After` 的计时器）将不得不等待 CPU，从而导致各种超时和延迟。

## gc 配置
> SetGCPercent(100)
GOGC 是一个比例值。GOGC=100（默认值）意味着，当新分配的内存达到**上一次GC结束后存活内存(live heap)**的 100% 时，才触发下一次 GC。

    总内存 ≈ 存活内存 + 新分配内存 = 上一次存活内存 + 上一次存活内存 * (GOGC / 100)

GOMEMLIMIT="2GiB" 绝对值

    当它预测到内存使用会超过 2GiB 时，就会触发 GC。
    它不再关心“存活内存的比例”，而是关心“距离2GiB的绝对空间还剩多少”。

# gc示例
## gc 回收示例
> 释放data 内存后:(示例参考 goos-tools/gonic/stat-os.go), alloc/inuse 不同的工具看到的结果不一样 

curl 'm:4500/stat/gc?act=large-memory' 后，
再 debug/pprof/heap?debug=1 会看到 heapAlloc/heapInuse 减少(会触发一次gc)
再go tool pprof -http=:4501 -alloc_space m:4500/debug/pprof/heap 

    TotalAlloc = 2,428791168
    Sys = 2490762072
    Lookups = 0
    Mallocs = 36382
    Frees = 23494
    HeapAlloc = 2,426764664
    HeapIdle = ,11,403,264
    HeapInuse = 2,429,026,304
    HeapReleased = ,10,469376
    HeapObjects = 12888
    Stack = 655360 / 655360
    MSpan = 167840 / 179520
    MCache = 12000 / 15600
    BuckHashSys = 1450481
    GCSys = 46082840
    OtherSys = 1948703
    NextGC = 11932863240
    LastGC = 1693554580854103000

curl 'm:4500/stat/gc?act=gc' gc 后:
curl 'm:4500/stat/gc?act=gc&type=os' gc+os release后: