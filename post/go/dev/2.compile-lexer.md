---
title: go compile lexerã€€è¯æ³•åˆ†æ
date: 2024-09-03
private: true
---
# Preface

# lex
> æœ¬æ–¹æ¶‰åŠçš„æºç è§ ./code/
> æ—©æœŸçš„ Go è¯­è¨€è™½ç„¶ä½¿ç”¨ lex è¿™ç§å·¥å…·æ¥ç”Ÿæˆè¯æ³•è§£æå™¨ï¼Œä½†æ˜¯æœ€åè¿˜æ˜¯ä½¿ç”¨ Go æ¥å®ç°è¯æ³•åˆ†æå™¨ï¼Œç”¨è‡ªå·±å†™çš„è¯æ³•åˆ†æå™¨æ¥è§£æè‡ªå·±8ã€‚
lex æ˜¯ç”¨äºç”Ÿæˆè¯æ³•åˆ†æå™¨çš„å·¥å…·.  å®ƒæ˜¯ä¸€ä¸ªé€šç”¨çš„æ­£åˆ™ç”Ÿæˆå™¨ï¼Œå°†ä»£ç ç¿»è¯‘æˆtoken. é€šç”¨äºå„ç±»è¯­è¨€ã€‚

## lex è§„åˆ™
ä¸€ä¸ªlexã€€æ–‡ä»¶ç¤ºä¾‹ï¼Œå®ƒå¯ä»¥ç”¨æ¥åŒ¹é…ç®€å•çš„go package/import/brace/Quotes å…³é”®å­—

    $ cat simplego.l
    %{
    #include <stdio.h>
    %}

    %%
    package      printf("PACKAGE ");
    import       printf("IMPORT ");
    \.           printf("DOT ");
    \{           printf("LBRACE ");
    \}           printf("RBRACE ");
    \(           printf("LPAREN ");
    \)           printf("RPAREN ");
    \"           printf("QUOTE ");
    \n           printf("\n");
    [0-9]+       printf("NUMBER ");
    [a-zA-Z_]+   printf("IDENT ");
    %%

## ç¼–è¯‘lex è§„åˆ™
lex è§„åˆ™æ˜¯ä¸ç”¨è¿è¡Œçš„ã€‚éœ€è¦ç”¨lexå‘½ä»¤ç¼–è¯‘ç”Ÿæˆ`*.yy.c`(flexåŒ…æä¾›, macã€€åº”è¯¥æ˜¯è‡ªå¸¦äº†)

    # brew instal flex æˆ–ç”¨è‡ªå¸¦çš„
    $ lex simplego.l
    $ cat lex.yy.c
    ...
    int yylex (void) {
        ...
        while ( 1 ) {
            ...
            yy_match:
                    do {
                        register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
                        if ( yy_accept[yy_current_state] ) {
                            (yy_last_accepting_state) = yy_current_state;
                            (yy_last_accepting_cpos) = yy_cp;
                        }
                        while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state ) {
                            yy_current_state = (int) yy_def[yy_current_state];
                            if ( yy_current_state >= 30 )
                                yy_c = yy_meta[(unsigned int) yy_c];
                            }
                        yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
                        ++yy_cp;
                    } while ( yy_base[yy_current_state] != 37 );
                    ...
            do_action:
                    switch ( yy_act )
                        case 1:
                            YY_RULE_SETUP
                            printf("PACKAGE ");
                            YY_BREAK

lex.yy.c4 çš„å‰ 600 è¡ŒåŸºæœ¬éƒ½æ˜¯å®å’Œå‡½æ•°çš„å£°æ˜å’Œå®šä¹‰ï¼Œåé¢ç”Ÿæˆçš„ä»£ç å¤§éƒ½æ˜¯ä¸º yylex è¿™ä¸ªå‡½æ•°æœåŠ¡çš„
è¿™ä¸ªyylex å‡½æ•°ä½¿ç”¨æœ‰é™è‡ªåŠ¨æœºï¼ˆDeterministic Finite Automatonã€DFAï¼‰çš„ç¨‹åºç»“æ„æ¥åˆ†æè¾“å…¥çš„å­—ç¬¦æµï¼Œ ä¸Šè¿°ä»£ç ä¸­ while å¾ªç¯å°±æ˜¯è¿™ä¸ªæœ‰é™è‡ªåŠ¨æœºçš„ä¸»ä½“.

å½“å‰çš„æ–‡ä»¶ä¸­å¹¶ä¸å­˜åœ¨ main å‡½æ•°ï¼Œmain å‡½æ•°æ˜¯åœ¨ liblex åº“ä¸­å®šä¹‰çš„ï¼Œæ‰€ä»¥åœ¨ç¼–è¯‘æ—¶å…¶å®éœ€è¦æ·»åŠ é¢å¤–çš„ -ll é€‰é¡¹ï¼š

    $ cc lex.yy.c -o simplego.bin -ll
    $ cat main.go | ./simplego.bin
    PACKAGE  IDENT 
    IMPORT  QUOTE IDENT QUOTE 
    ...

# goè¯æ³•åˆ†æ(syntax.scanner)
scanner: Go è¯­è¨€çš„è¯æ³•è§£ææ˜¯é€šè¿‡ src/cmd/compile/internal/syntax/scanner.go æ–‡ä»¶ä¸­çš„ scanner ç»“æ„ä½“å®ç°çš„

    // è¿™ä¸ªç»“æ„ä½“ä¼šæŒæœ‰å½“å‰æ‰«æçš„æ•°æ®æºæ–‡ä»¶ã€å¯ç”¨çš„æ¨¡å¼å’Œå½“å‰è¢«æ‰«æåˆ°çš„ Token
    type scanner struct {
        source
        mode   uint
        nlsemi bool

        // current token, valid after calling next()
        line, col uint
        blank     bool // line is blank up to col
        tok       token
        lit       string   // valid if tok is _Name, _Literal, or _Semi ("semicolon", "newline", or "EOF"); may be malformed if bad is true
        bad       bool     // valid if tok is _Literal, true if a syntax error occurred, lit may be malformed
        kind      LitKind  // valid if tok is _Literal
        op        Operator // valid if tok is _Operator, _AssignOp, or _IncOp
        prec      int      // valid if tok is _Operator, _AssignOp, or _IncOp
    }

go token å¯åˆ†æˆå‡ ä¸ªä¸åŒçš„ç±»åˆ«: åç§°å’Œå­—é¢é‡ã€æ“ä½œç¬¦ã€åˆ†éš”ç¬¦å’Œå…³é”®å­—ã€‚
src/cmd/compile/internal/syntax/tokens.go æ–‡ä»¶ä¸­å®šä¹‰äº† Go è¯­è¨€ä¸­æ”¯æŒçš„å…¨éƒ¨ Token ç±»å‹ï¼Œ

    const (
        _    token = iota
        _EOF       // EOF

        // operators and operations
        _Operator // op
        ...

        // delimiters
        _Lparen    // (
        _Lbrack    // [
        ...

        // keywords
        _Break       // break
        ...
        _Type        // type
        _Var         // var

    )

è¯æ³•åˆ†æä¸»è¦æ˜¯ç”± cmd/compile/internal/syntax.scanner è¿™ä¸ªç»“æ„ä½“ä¸­çš„ syntax.scanner.next æ–¹æ³•é©±åŠ¨ï¼Œè¿™ä¸ª 250 è¡Œå‡½æ•°çš„ä¸»ä½“æ˜¯ä¸€ä¸ª switch/case ç»“æ„ï¼š

    func (s *scanner) next() {
        ...
        s.stop()
        startLine, startCol := s.pos()
        for s.ch == ' ' || s.ch == '\t' || s.ch == '\n' && !nlsemi || s.ch == '\r' {
            s.nextch()
        }

        s.line, s.col = s.pos()
        s.blank = s.line > startLine || startCol == colbase
        s.start()
        if isLetter(s.ch) || s.ch >= utf8.RuneSelf && s.atIdentChar(true) {
            s.nextch()
            s.ident()
            return
        }

        switch s.ch {
        case -1:
            s.tok = _EOF

        case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
            s.number(false)
        ...
        }
    }

cmd/compile/internal/syntax.scanner æ¯æ¬¡éƒ½ä¼šé€šè¿‡ cmd/compile/internal/syntax.source.nextch å‡½æ•°è·å–æ–‡ä»¶ä¸­æœ€è¿‘çš„æœªè¢«è§£æçš„å­—ç¬¦ï¼Œç„¶åæ ¹æ®å½“å‰å­—ç¬¦çš„ä¸åŒæ‰§è¡Œä¸åŒçš„ case.

1.å¦‚æœé‡åˆ°äº†ç©ºæ ¼å’Œæ¢è¡Œç¬¦è¿™äº›ç©ºç™½å­—ç¬¦ä¼šç›´æ¥è·³è¿‡
2.å¦‚æœå½“å‰å­—ç¬¦æ˜¯ 0 å°±ä¼šæ‰§è¡Œ cmd/compile/internal/syntax.scanner.number æ–¹æ³•å°è¯•åŒ¹é…ä¸€ä¸ªæ•°å­—ã€‚

    // åˆ†æåŒ¹é…æµ®ç‚¹æ•°ã€æŒ‡æ•°å’Œå¤æ•°
    func (s *scanner) number(seenPoint bool) {
        kind := IntLit
        base := 10        // number base
        digsep := 0
        invalid := -1     // index of invalid digit in literal, or < 0

        s.kind = IntLit
        if !seenPoint {
            digsep |= s.digits(base, &invalid)
        }

        s.setLit(kind, ok)
    }

    func (s *scanner) digits(base int, invalid *int) (digsep int) {
        max := rune('0' + base)
        for isDecimal(s.ch) || s.ch == '_' {
            ds := 1
            if s.ch == '_' {
                ds = 2
            } else if s.ch >= max && *invalid < 0 {
                _, col := s.pos()
                *invalid = int(col - s.col) // record invalid rune index
            }
            digsep |= ds
            s.nextch()
        }
        return
    }

è¯æ³•åˆ†æåŒ¹é…æ•´æ•°çš„é€»è¾‘ï¼š
1. åœ¨ for å¾ªç¯ä¸­ä¸æ–­è·å–æœ€æ–°çš„å­—ç¬¦ï¼Œå°†å­—ç¬¦é€šè¿‡ syntax.source.nextch æ–¹æ³•è¿½åŠ åˆ° syntax.scanner æŒæœ‰çš„ç¼“å†²åŒºä¸­ï¼›
2. å½“å‰åŒ…ä¸­çš„è¯æ³•åˆ†æå™¨ syntax.scanner ä¹Ÿåªæ˜¯ä¸ºä¸Šå±‚æä¾›äº† syntax.scanner.next æ–¹æ³•

# è¯­æ³•åˆ†æ(syntax.parser)
è¯­æ³•åˆ†ææ˜¯æ ¹æ®æŸç§ç‰¹å®šçš„å½¢å¼æ–‡æ³•ï¼ˆGrammarï¼‰å¯¹ Token åºåˆ—æ„æˆçš„è¾“å…¥æ–‡æœ¬è¿›è¡Œåˆ†æå¹¶ç¡®å®šå…¶è¯­æ³•ç»“æ„çš„è¿‡ç¨‹ã€‚

å…ˆäº†è§£è¯­æ³•åˆ†æä¸­çš„æ–‡æ³•å’Œåˆ†ææ–¹æ³•ã€‚

## æ–‡æ³•
ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•æ˜¯ç”¨æ¥å½¢å¼åŒ–ã€ç²¾ç¡®æè¿°æŸç§ç¼–ç¨‹è¯­è¨€çš„å·¥å…·ï¼Œå®ƒåŒ…å«ä¸€ç³»åˆ—ç”¨äºè½¬æ¢å­—ç¬¦ä¸²çš„ç”Ÿäº§è§„åˆ™ï¼ˆProduction ruleï¼‰ã€‚

æ¯ä¸€ä¸ªç”Ÿäº§è§„åˆ™(æœ‰é™çŠ¶æ€æœº)éƒ½ä¼šå°†è§„åˆ™`å·¦ä¾§çš„éç»ˆç»“ç¬¦`è½¬æ¢æˆ`å³ä¾§çš„å­—ç¬¦ä¸²`ï¼Œæ–‡æ³•éƒ½ç”±ä»¥ä¸‹çš„å››ä¸ªéƒ¨åˆ†ç»„æˆï¼š

    // tip: ç»ˆç»“ç¬¦æ˜¯æ–‡æ³•ä¸­æ— æ³•å†è¢«å±•å¼€çš„ç¬¦å·ï¼Œè€Œéç»ˆç»“ç¬¦ä¸ä¹‹ç›¸å

    ğ‘ æœ‰é™ä¸ªéç»ˆç»“ç¬¦çš„é›†åˆï¼›
    Î£ æœ‰é™ä¸ªç»ˆç»“ç¬¦çš„é›†åˆï¼›
    ğ‘ƒ æœ‰é™ä¸ªç”Ÿäº§è§„åˆ™çš„é›†åˆï¼›
    ğ‘† éç»ˆç»“ç¬¦é›†åˆä¸­å”¯ä¸€çš„å¼€å§‹ç¬¦å·ï¼›

æ–‡æ³•è¢«å®šä¹‰æˆä¸€ä¸ªå››å…ƒç»„ `(ğ‘,Î£,ğ‘ƒ,ğ‘†)` ï¼Œè¿™ä¸ªå…ƒç»„ä¸­çš„å‡ éƒ¨åˆ†æ˜¯ä¸Šé¢æåˆ°çš„å››ä¸ªç¬¦å·ï¼Œå…¶ä¸­æ¯ä¸ªç”Ÿäº§è§„åˆ™P éƒ½ä¼šåŒ…å«éç»ˆç»“ç¬¦ã€ç»ˆç»“ç¬¦æˆ–è€…å¼€å§‹ç¬¦å·ï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œå¯ä»¥ä¸¾ä¸ªç®€å•çš„ä¾‹å­ï¼š

    ğ‘†â†’ğ‘ğ‘†ğ‘
    ğ‘†â†’ğ‘ğ‘
    ğ‘†â†’ğœ–

ä¸Šè¿°è§„åˆ™æ„æˆçš„æ–‡æ³•å°±èƒ½å¤Ÿè¡¨ç¤º abã€aabb ä»¥åŠ aaa..bbb ç­‰å­—ç¬¦ä¸²ï¼Œç¼–ç¨‹è¯­è¨€çš„æ–‡æ³•å°±æ˜¯ç”±è¿™ä¸€ç³»åˆ—çš„ç”Ÿäº§è§„åˆ™è¡¨ç¤ºçš„ï¼Œåœ¨è¿™é‡Œæˆ‘ä»¬å¯ä»¥ä» src/cmd/compile/internal/syntax/parser.go13 æ–‡ä»¶ä¸­æ‘˜æŠ„ä¸€äº› Go è¯­è¨€æ–‡æ³•çš„ç”Ÿäº§è§„åˆ™ï¼š

    SourceFile = PackageClause ";" { ImportDecl ";" } { TopLevelDecl ";" } .
    PackageClause  = "package" PackageName .
    PackageName    = identifier .

    ImportDecl       = "import" ( ImportSpec | "(" { ImportSpec ";" } ")" ) .
    ImportSpec       = [ "." | PackageName ] ImportPath .
    ImportPath       = string_lit .

    TopLevelDecl  = Declaration | FunctionDecl | MethodDecl .
    Declaration   = ConstDecl | TypeDecl | VarDecl .

> Go è¯­è¨€æ›´è¯¦ç»†çš„æ–‡æ³•å¯ä»¥ä» Language Specification14 ä¸­æ‰¾åˆ°ï¼Œè¿™é‡Œä¸ä»…åŒ…å«è¯­è¨€çš„æ–‡æ³•ï¼Œè¿˜åŒ…å«è¯æ³•å…ƒç´ ã€å†…ç½®å‡½æ•°ç­‰ä¿¡æ¯ã€‚

å› ä¸ºæ¯ä¸ª Go æºä»£ç æ–‡ä»¶æœ€ç»ˆéƒ½ä¼šè¢«è§£ææˆä¸€ä¸ªç‹¬ç«‹çš„æŠ½è±¡è¯­æ³•æ ‘ï¼Œæ‰€ä»¥è¯­æ³•æ ‘æœ€é¡¶å±‚çš„ç»“æ„æˆ–è€…å¼€å§‹ç¬¦å·éƒ½æ˜¯ SourceFileï¼š

    SourceFile = PackageClause ";" { ImportDecl ";" } { TopLevelDecl ";" } .

ä» SourceFile ç›¸å…³çš„ç”Ÿäº§è§„åˆ™æˆ‘ä»¬å¯ä»¥çœ‹å‡ºï¼Œæ¯ä¸€ä¸ªæ–‡ä»¶éƒ½åŒ…å«ä¸€ä¸ª package çš„å®šä¹‰ä»¥åŠå¯é€‰çš„ import å£°æ˜å’Œå…¶ä»–çš„é¡¶å±‚å£°æ˜ï¼ˆTopLevelDeclï¼‰ï¼Œæ¯ä¸€ä¸ª SourceFile åœ¨ç¼–è¯‘å™¨ä¸­éƒ½å¯¹åº”ä¸€ä¸ª cmd/compile/internal/syntax.File ç»“æ„ä½“ï¼Œä½ èƒ½ä»å®ƒä»¬çš„å®šä¹‰ä¸­è½»æ¾æ‰¾åˆ°ä¸¤è€…çš„è”ç³»ï¼š

    type File struct {
        Pragma   Pragma
        PkgName  *Name
        DeclList []Decl
        Lines    uint
        node
    }

é¡¶å±‚å£°æ˜æœ‰äº”å¤§ç±»å‹ï¼Œåˆ†åˆ«æ˜¯å¸¸é‡ã€ç±»å‹ã€å˜é‡ã€å‡½æ•°å’Œæ–¹æ³•ï¼Œä½ å¯ä»¥åœ¨æ–‡ä»¶ src/cmd/compile/internal/syntax/parser.go ä¸­æ‰¾åˆ°è¿™äº”å¤§ç±»å‹çš„å®šä¹‰ã€‚
ä¸‹é¢çš„æ–‡æ³•åˆ†åˆ«å®šä¹‰äº† Go è¯­è¨€ä¸­å¸¸é‡ã€ç±»å‹å’Œå˜é‡ä¸‰ç§å¸¸è§çš„ç»“æ„:

    ConstDecl = "const" ( ConstSpec | "(" { ConstSpec ";" } ")" ) .
    ConstSpec = IdentifierList [ [ Type ] "=" ExpressionList ] .

    TypeDecl  = "type" ( TypeSpec | "(" { TypeSpec ";" } ")" ) .
    TypeSpec  = AliasDecl | TypeDef .
    AliasDecl = identifier "=" Type .
    TypeDef   = identifier Type .

    VarDecl = "var" ( VarSpec | "(" { VarSpec ";" } ")" ) .
    VarSpec = IdentifierList ( Type [ "=" ExpressionList ] | "=" ExpressionList ) .

å‡½æ•°å’Œæ–¹æ³•çš„å®šä¹‰å°±æ›´åŠ å¤æ‚ï¼Œä»ä¸‹é¢çš„æ–‡æ³•æˆ‘ä»¬å¯ä»¥çœ‹åˆ° Statement æ€»å…±å¯ä»¥è½¬æ¢æˆ 15 ç§ä¸åŒçš„è¯­æ³•ç»“æ„ï¼Œè¿™äº›è¯­æ³•ç»“æ„å°±åŒ…æ‹¬æˆ‘ä»¬ç»å¸¸ä½¿ç”¨çš„ switch/caseã€if/elseã€for å¾ªç¯ä»¥åŠ select ç­‰è¯­å¥ï¼š

    FunctionDecl = "func" FunctionName Signature [ FunctionBody ] .
    FunctionName = identifier .
    FunctionBody = Block .

    MethodDecl = "func" Receiver MethodName Signature [ FunctionBody ] .
    Receiver   = Parameters .

    Block = "{" StatementList "}" .
    StatementList = { Statement ";" } .

    Statement =
        Declaration | LabeledStmt | SimpleStmt |
        GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |
        FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |
        DeferStmt .

    SimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .

> å¯¹äº Statement å±•å¼€å‚è€ƒ src/cmd/compile/internal/syntax/parser.go 

## åˆ†ææ–¹æ³•
è¯­æ³•åˆ†æçš„åˆ†ææ–¹æ³•ä¸€èˆ¬åˆ†ä¸ºè‡ªé¡¶å‘ä¸‹å’Œè‡ªåº•å‘ä¸Šå¯¹è¾“å…¥çš„ Token åºåˆ—è¿›è¡Œæ¨å¯¼ï¼š

1. è‡ªé¡¶å‘ä¸‹åˆ†æï¼šå¯ä»¥è¢«çœ‹ä½œæ‰¾åˆ°å½“å‰è¾“å…¥æµæœ€å·¦æ¨å¯¼çš„è¿‡ç¨‹ï¼Œå¯¹äºä»»æ„ä¸€ä¸ªè¾“å…¥æµï¼Œæ ¹æ®å½“å‰çš„è¾“å…¥ç¬¦å·ï¼Œç¡®å®šä¸€ä¸ªç”Ÿäº§è§„åˆ™ï¼Œä½¿ç”¨ç”Ÿäº§è§„åˆ™å³ä¾§çš„ç¬¦å·æ›¿ä»£ç›¸åº”çš„éç»ˆç»“ç¬¦å‘ä¸‹æ¨å¯¼ï¼›
2. è‡ªåº•å‘ä¸Šåˆ†æï¼šè¯­æ³•åˆ†æå™¨ä»è¾“å…¥æµå¼€å§‹ï¼Œæ¯æ¬¡éƒ½å°è¯•é‡å†™æœ€å³ä¾§çš„å¤šä¸ªç¬¦å·ï¼Œè¿™å…¶å®æ˜¯è¯´è§£æå™¨ä¼šä»æœ€ç®€å•çš„ç¬¦å·è¿›è¡Œæ¨å¯¼ï¼Œåœ¨è§£æçš„æœ€ååˆå¹¶æˆå¼€å§‹ç¬¦å·ï¼›

### è‡ªé¡¶å‘ä¸‹
LL æ–‡æ³•æ˜¯ä¸€ç§ä½¿ç”¨è‡ªé¡¶å‘ä¸‹åˆ†ææ–¹æ³•çš„æ–‡æ³•ï¼Œä¸‹é¢ç»™å‡ºäº†ä¸€ä¸ªå¸¸è§çš„ LL æ–‡æ³•ï¼š

    ğ‘†â†’ğ‘ğ‘†1
    ğ‘†1â†’ğ‘ğ‘†1
    ğ‘†1â†’ğœ–

å‡è®¾æˆ‘ä»¬å­˜åœ¨ä»¥ä¸Šçš„ç”Ÿäº§è§„åˆ™å’Œè¾“å…¥æµ abbï¼Œå¦‚æœè¿™é‡Œä½¿ç”¨è‡ªé¡¶å‘ä¸‹çš„æ–¹å¼è¿›è¡Œè¯­æ³•åˆ†æï¼Œï¼š

    ğ‘†
    ï¼ˆå¼€å§‹ç¬¦å·ï¼‰
    ğ‘ğ‘†1
    ï¼ˆè§„åˆ™ 1)
    ğ‘ğ‘ğ‘†1
    ï¼ˆè§„åˆ™ 2)
    ğ‘ğ‘ğ‘ğ‘†1
    ï¼ˆè§„åˆ™ 2)
    ğ‘ğ‘ğ‘
    ï¼ˆè§„åˆ™ 3)

è¿™ç§åˆ†ææ–¹æ³•ä¸€å®šä¼šä»å¼€å§‹ç¬¦å·åˆ†æï¼Œé€šè¿‡ä¸‹ä¸€ä¸ªå³å°†å…¥æ ˆçš„ç¬¦å·åˆ¤æ–­å¦‚æœå¯¹å³ä¾§éç»ˆç»“ç¬¦ï¼ˆğ‘† æˆ– ğ‘†1 ï¼‰è¿›è¡Œå±•å¼€ï¼Œç›´åˆ°æ•´ä¸ªå­—ç¬¦ä¸²ä¸­ä¸å­˜åœ¨ä»»ä½•çš„éç»ˆç»“ç¬¦ï¼Œæ•´ä¸ªè§£æè¿‡ç¨‹æ‰ä¼šç»“æŸã€‚

### è‡ªåº•å‘ä¸Š
ä½†æ˜¯å¦‚æœæˆ‘ä»¬ä½¿ç”¨è‡ªåº•å‘ä¸Šçš„æ–¹å¼å¯¹è¾“å…¥æµè¿›è¡Œåˆ†ææ—¶ï¼Œå¤„ç†è¿‡ç¨‹å°±ä¼šå®Œå…¨ä¸åŒäº†ï¼Œå¸¸è§çš„å››ç§æ–‡æ³• LR(0)ã€SLRã€LR(1) å’Œ LALR(1) ä½¿ç”¨äº†è‡ªåº•å‘ä¸Šçš„å¤„ç†æ–¹å¼ï¼Œæˆ‘ä»¬å¯ä»¥ç®€å•å†™ä¸€ä¸ªä¸ä¸Šä¸€èŠ‚ä¸­æ•ˆæœç›¸åŒçš„ LR(0) æ–‡æ³•ï¼š

    ğ‘†â†’ğ‘†1
    ğ‘†1â†’ğ‘†1ğ‘
    ğ‘†1â†’ğ‘

ä½¿ç”¨ä¸Šè¿°ç­‰æ•ˆçš„æ–‡æ³•å¤„ç†åŒæ ·åœ°è¾“å…¥æµ abb ä¼šä½¿ç”¨å®Œå…¨ä¸åŒçš„è¿‡ç¨‹å¯¹è¾“å…¥æµè¿›è¡Œå±•å¼€(é€†å‘åŒ¹é…)ï¼š

    ğ‘
    ï¼ˆå…¥æ ˆï¼‰
    ğ‘†1
    ï¼ˆè§„åˆ™ 3ï¼‰
    ğ‘†1ğ‘
    ï¼ˆå…¥æ ˆï¼‰
    ğ‘†1
    ï¼ˆè§„åˆ™ 2ï¼‰
    ğ‘†1ğ‘
    ï¼ˆå…¥æ ˆï¼‰
    ğ‘†1
    ï¼ˆè§„åˆ™ 2ï¼‰
    ğ‘†
    ï¼ˆè§„åˆ™ 1ï¼‰

è‡ªåº•å‘ä¸Šçš„åˆ†æè¿‡ç¨‹ä¼šç»´æŠ¤ä¸€ä¸ªæ ˆç”¨äºå­˜å‚¨æœªè¢«å½’çº¦çš„ç¬¦å·ï¼Œåœ¨æ•´ä¸ªè¿‡ç¨‹ä¸­ä¼šæ‰§è¡Œä¸¤ç§ä¸åŒçš„æ“ä½œï¼Œä¸€ç§å«åšå…¥æ ˆï¼ˆShiftï¼‰ï¼Œä¹Ÿå°±æ˜¯å°†ä¸‹ä¸€ä¸ªç¬¦å·å…¥æ ˆï¼Œå¦ä¸€ç§å«åšå½’çº¦ï¼ˆReduceï¼‰ï¼Œä¹Ÿå°±æ˜¯å¯¹æœ€å³ä¾§çš„å­—ç¬¦ä¸²æŒ‰ç…§ç”Ÿäº§è§„åˆ™è¿›è¡Œåˆå¹¶ã€‚

ä¸Šè¿°çš„åˆ†æè¿‡ç¨‹å’Œè‡ªé¡¶å‘ä¸‹çš„åˆ†ææ–¹æ³•å®Œå…¨ä¸åŒï¼Œè¿™ä¸¤ç§ä¸åŒçš„åˆ†ææ–¹æ³•å…¶å®ä¹Ÿä»£è¡¨äº†è®¡ç®—æœºç§‘å­¦ä¸­ä¸¤ç§ä¸åŒçš„æ€æƒ³ â€” ä»æŠ½è±¡åˆ°å…·ä½“å’Œä»å…·ä½“åˆ°æŠ½è±¡ã€‚

### Lookahead
åœ¨è¯­æ³•åˆ†æä¸­é™¤äº† LL å’Œ LR è¿™ä¸¤ç§ä¸åŒç±»å‹çš„è¯­æ³•åˆ†ææ–¹æ³•ä¹‹å¤–ï¼Œè¿˜å­˜åœ¨å¦ä¸€ä¸ªéå¸¸é‡è¦çš„æ¦‚å¿µï¼Œå°±æ˜¯å‘å‰æŸ¥çœ‹ï¼ˆLookaheadï¼‰ï¼Œåœ¨ä¸åŒç”Ÿäº§è§„åˆ™å‘ç”Ÿå†²çªæ—¶ï¼Œå½“å‰è§£æå™¨éœ€è¦é€šè¿‡é¢„è¯»ä¸€äº› Token åˆ¤æ–­å½“å‰åº”è¯¥ç”¨ä»€ä¹ˆç”Ÿäº§è§„åˆ™å¯¹è¾“å…¥æµè¿›è¡Œå±•å¼€æˆ–è€…å½’çº¦ï¼Œä¾‹å¦‚åœ¨ LALR(1) æ–‡æ³•ä¸­ï¼Œéœ€è¦é¢„è¯»ä¸€ä¸ª Token ä¿è¯å‡ºç°å†²çªçš„ç”Ÿäº§è§„åˆ™èƒ½å¤Ÿè¢«æ­£ç¡®å¤„ç†ã€‚

## goè¯­æ³•åˆ†æ(syntax.parser)
> Go è¯­è¨€çš„è§£æå™¨ä½¿ç”¨äº† LALR(1) çš„æ–‡æ³•æ¥è§£æè¯æ³•åˆ†æè¿‡ç¨‹ä¸­è¾“å‡ºçš„ Token åºåˆ—ï¼Œæœ€å³æ¨å¯¼åŠ å‘å‰æŸ¥çœ‹æ„æˆäº† Go è¯­è¨€è§£æå™¨çš„æœ€åŸºæœ¬åŸç†ï¼Œä¹Ÿæ˜¯å¤§å¤šæ•°ç¼–ç¨‹è¯­è¨€çš„é€‰æ‹©ã€‚

æˆ‘ä»¬åœ¨æ¦‚è¿°ä¸­å·²ç»ä»‹ç»äº†ç¼–è¯‘å™¨çš„ä¸»å‡½æ•°:
1. è¯¥å‡½æ•°è°ƒç”¨çš„ cmd/compile/internal/gc.parseFiles ä¼šä½¿ç”¨å¤šä¸ª Goroutine æ¥è§£ææºæ–‡ä»¶ï¼Œ
2. è§£æçš„è¿‡ç¨‹ä¼šè°ƒç”¨ cmd/compile/internal/syntax.Parseï¼Œ
3. è¯¥å‡½æ•°åˆå§‹åŒ–äº†ä¸€ä¸ªæ–°çš„ cmd/compile/internal/syntax.parser ç»“æ„ä½“
   1. å¹¶é€šè¿‡ cmd/compile/internal/syntax.parser.fileOrNil æ–¹æ³•å¼€å¯å¯¹å½“å‰æ–‡ä»¶çš„è¯æ³•å’Œè¯­æ³•è§£æï¼š

### fileOrNil åˆ†æ
ç¤ºä¾‹ï¼š

    func Parse(base *PosBase, src io.Reader, errh ErrorHandler, pragh PragmaHandler, mode Mode) (_ *File, first error) {
        var p parser
        p.init(base, src, errh, pragh, mode)
        p.next()
        return p.fileOrNil(), p.first
    }

#### fileOrNil åˆ†æå…¥å£
cmd/compile/internal/syntax.parser.fileOrNil æ–¹æ³•å…¶å®æ˜¯å¯¹ä¸Šé¢ä»‹ç»çš„ Go è¯­è¨€æ–‡æ³•çš„å®ç°ï¼Œè¯¥æ–¹æ³•é¦–å…ˆä¼šè§£ææ–‡ä»¶å¼€å¤´çš„ package å®šä¹‰ï¼š

    // SourceFile = PackageClause ";" { ImportDecl ";" } { TopLevelDecl ";" } .
    func (p *parser) fileOrNil() *File {
        f := new(File)
        f.pos = p.pos()

        if !p.got(_Package) {
            p.syntaxError("package statement must be first")
            return nil
        }
        f.PkgName = p.name()
        p.want(_Semi)

ä»ä¸Šé¢çš„è¿™ä¸€æ®µæ–¹æ³•ä¸­æˆ‘ä»¬å¯ä»¥çœ‹å‡ºï¼Œå½“å‰æ–¹æ³•ä¼šé€šè¿‡ cmd/compile/internal/syntax.parser.got æ¥åˆ¤æ–­ä¸‹ä¸€ä¸ª Token æ˜¯ä¸æ˜¯ package å…³é”®å­—ï¼Œå¦‚æœæ˜¯ package å…³é”®å­—ï¼Œå°±ä¼šæ‰§è¡Œ cmd/compile/internal/syntax.parser.name æ¥åŒ¹é…ä¸€ä¸ªåŒ…åå¹¶å°†ç»“æœä¿å­˜åˆ°è¿”å›çš„æ–‡ä»¶ç»“æ„ä½“ä¸­ã€‚

	for p.got(_Import) {
		f.DeclList = p.appendGroup(f.DeclList, p.importDecl)
		p.want(_Semi)
	}

ç¡®å®šäº†å½“å‰æ–‡ä»¶çš„åŒ…åä¹‹åï¼Œå°±å¼€å§‹è§£æå¯é€‰çš„ import å£°æ˜ï¼Œæ¯ä¸€ä¸ª import åœ¨è§£æå™¨çœ‹æ¥éƒ½æ˜¯ä¸€ä¸ªå£°æ˜è¯­å¥ï¼Œè¿™äº›å£°æ˜è¯­å¥éƒ½ä¼šè¢«åŠ å…¥åˆ°æ–‡ä»¶çš„ DeclList ä¸­ã€‚

åœ¨è¿™ä¹‹åä¼šæ ¹æ®ç¼–è¯‘å™¨è·å–çš„å…³é”®å­—è¿›å…¥ switch çš„ä¸åŒåˆ†æ”¯ï¼Œè¿™äº›åˆ†æ”¯è°ƒç”¨ cmd/compile/internal/syntax.parser.appendGroup æ–¹æ³•å¹¶åœ¨æ–¹æ³•ä¸­ä¼ å…¥ç”¨äºå¤„ç†å¯¹åº”ç±»å‹è¯­å¥çš„ cmd/compile/internal/syntax.parser.constDeclã€cmd/compile/internal/syntax.parser.typeDecl å‡½æ•°ã€‚

	for p.tok != _EOF {
		switch p.tok {
		case _Const:
			p.next()
			f.DeclList = p.appendGroup(f.DeclList, p.constDecl)

		case _Type:
			p.next()
			f.DeclList = p.appendGroup(f.DeclList, p.typeDecl)

		case _Var:
			p.next()
			f.DeclList = p.appendGroup(f.DeclList, p.varDecl)

		case _Func:
			p.next()
			if d := p.funcDeclOrNil(); d != nil {
				f.DeclList = append(f.DeclList, d)
			}
		default:
			...
		}
	}

	f.Lines = p.source.line

	return f

cmd/compile/internal/syntax.parser.fileOrNil ä½¿ç”¨äº†éå¸¸å¤šçš„å­æ–¹æ³•å¯¹è¾“å…¥çš„æ–‡ä»¶è¿›è¡Œè¯­æ³•åˆ†æï¼Œå¹¶åœ¨æœ€åä¼šè¿”å›æ–‡ä»¶å¼€å§‹åˆ›å»ºçš„ cmd/compile/internal/syntax.File ç»“æ„ä½“ã€‚

#### parser ä¸ã€€scanner
è¯»åˆ°è¿™é‡Œçš„äººå¯èƒ½ä¼šæœ‰ä¸€äº›ç–‘æƒ‘ï¼Œä¸ºä»€ä¹ˆæ²¡æœ‰çœ‹åˆ°è¯æ³•åˆ†æçš„ä»£ç ï¼Œè¿™æ˜¯å› ä¸º:
1. å› ä¸ºè¯æ³•åˆ†æå™¨ cmd/compile/internal/syntax.scanner ä½œä¸ºç»“æ„ä½“è¢«åµŒå…¥åˆ°äº† cmd/compile/internal/syntax.parser ä¸­ï¼Œ
2. æ‰€ä»¥è¿™ä¸ªæ–¹æ³•ä¸­çš„ p.next() å®é™…ä¸Šè°ƒç”¨çš„æ˜¯ cmd/compile/internal/syntax.scanner.next æ–¹æ³•ï¼Œå®ƒä¼šç›´æ¥è·å–æ–‡ä»¶ä¸­çš„ä¸‹ä¸€ä¸ª Tokenï¼Œæ‰€ä»¥è¯æ³•å’Œè¯­æ³•åˆ†æä¸€èµ·è¿›è¡Œçš„ã€‚

#### fileOrNil å­æ ‘
cmd/compile/internal/syntax.parser.fileOrNil ä¸åœ¨è¿™ä¸ªæ–¹æ³•ä¸­æ‰§è¡Œçš„å…¶ä»–å­æ–¹æ³•å…±åŒæ„æˆäº†ä¸€æ£µæ ‘:
1. è¿™æ£µæ ‘æ ¹èŠ‚ç‚¹æ˜¯ cmd/compile/internal/syntax.parser.fileOrNilï¼Œ
2. å­èŠ‚ç‚¹æ˜¯ cmd/compile/internal/syntax.parser.importDeclã€cmd/compile/internal/syntax.parser.constDecl ç­‰æ–¹æ³•ï¼Œå®ƒä»¬ä¸ Go è¯­è¨€æ–‡æ³•ä¸­çš„ç”Ÿäº§è§„åˆ™ä¸€ä¸€å¯¹åº”ã€‚

e.g.

    fileOrNil:
        constDecl
        varDecl
        importDecl
        TypeDecl
        funcDeclOrNil: (name + funcType + funcBody)

#### ç”Ÿäº§è§„åˆ™
cmd/compile/internal/syntax.parser.fileOrNilã€cmd/compile/internal/syntax.parser.constDecl ç­‰æ–¹æ³•å¯¹åº”äº† Go è¯­è¨€ä¸­çš„ç”Ÿäº§è§„åˆ™ï¼Œä¾‹å¦‚ cmd/compile/internal/syntax.parser.fileOrNil å®ç°çš„æ˜¯ï¼š

    SourceFile = PackageClause ";" { ImportDecl ";" } { TopLevelDecl ";" } .

é€šè¿‡å°†ç¼–ç¨‹è¯­è¨€çš„æ‰€æœ‰ç”Ÿäº§è§„åˆ™æ˜ å°„åˆ°å¯¹åº”çš„æ–¹æ³•ä¸Šï¼Œè¿™äº›æ–¹æ³•æ„æˆçš„æ ‘å½¢ç»“æ„æœ€ç»ˆä¼šè¿”å›ä¸€ä¸ªæŠ½è±¡è¯­æ³•æ ‘ã€‚

> è¿™é‡Œåªè®²äº†syntax.parser.fileOrNil æ–¹æ³•çš„å®ç°äº†ï¼Œå…¶å®ƒå‚è€ƒ src/cmd/compile/internal/syntax/parser.go (åŒ…å«äº†è¯­æ³•åˆ†æé˜¶æ®µçš„å…¨éƒ¨æ–¹æ³•)

### è¾…åŠ©æ–¹æ³•
è¿™é‡Œè®²ä¸€ä¸‹è§£æå™¨è¿è¡Œè¿‡ç¨‹ä¸­æœ‰å‡ ä¸ªè¾…åŠ©æ–¹æ³•

#### got+want
é¦–å…ˆå°±æ˜¯ cmd/compile/internal/syntax.parser.got å’Œ cmd/compile/internal/syntax.parser.want è¿™ä¸¤ä¸ªå¸¸è§çš„æ–¹æ³•ï¼š

    // syntax.parser.got åªæ˜¯ç”¨äºå¿«é€Ÿåˆ¤æ–­ä¸€äº›è¯­å¥ä¸­çš„å…³é”®å­—ï¼Œå¦‚æœå½“å‰è§£æå™¨ä¸­çš„ Token æ˜¯ä¼ å…¥çš„ Token å°±ä¼šç›´æ¥è·³è¿‡è¯¥ Token å¹¶è¿”å› trueï¼›
    func (p *parser) got(tok token) bool {
        if p.tok == tok {
            p.next()
            return true
        }
        return false
    }

    // syntax.parser.want å°±æ˜¯å¯¹ syntax.parser.got çš„ç®€å•å°è£…äº†
    func (p *parser) want(tok token) {
        if !p.got(tok) {
            p.syntaxError("expecting " + tokstring(tok))
            p.advance()
        }
    }

#### appendGroup
å¦ä¸€ä¸ªæ–¹æ³• cmd/compile/internal/synctax.parser.appendGroup çš„å®ç°å°±ç¨å¾®å¤æ‚äº†ä¸€ç‚¹ï¼Œå®ƒçš„ä¸»è¦ä½œç”¨å°±æ˜¯æ‰¾å‡ºæ‰¹é‡çš„å®šä¹‰ï¼Œä¸¾ä¸€ä¸ªä¾‹å­ï¼š

    var (
        a int
        b int
    )

è¿™ä¸¤ä¸ªå˜é‡å…¶å®å±äºåŒä¸€ä¸ªç»„ï¼ˆGroupï¼‰ï¼Œå„ç§é¡¶å±‚å®šä¹‰çš„ç»“æ„ä½“ cmd/compile/internal/syntax.parser.constDeclã€cmd/compile/internal/syntax.parser.varDecl åœ¨è¿›è¡Œè¯­æ³•åˆ†ææ—¶æœ‰ä¸€ä¸ªé¢å¤–çš„å‚æ•° cmd/compile/internal/syntax.Groupï¼Œè¿™ä¸ªå‚æ•°æ˜¯é€šè¿‡ appendGroup æ–¹æ³•ä¼ é€’è¿›å»çš„ï¼š

    func (p *parser) appendGroup(list []Decl, f func(*Group) Decl) []Decl {
        if p.tok == _Lparen {
            g := new(Group)
            p.list(_Lparen, _Semi, _Rparen, func() bool {
                list = append(list, f(g))
                return false
            })
        } else {
            list = append(list, f(nil))
        }

        return list
    }

syntax.parser.appendGroup æ–¹æ³•ä¼šè°ƒç”¨ä¼ å…¥çš„ f æ–¹æ³•å¯¹è¾“å…¥æµè¿›è¡ŒåŒ¹é…å¹¶å°†åŒ¹é…çš„ç»“æœè¿½åŠ åˆ°å¦ä¸€ä¸ªå‚æ•° syntax.File ç»“æ„ä½“ä¸­çš„ DeclList æ•°ç»„ä¸­ï¼Œ
importã€constã€varã€type å’Œ func å£°æ˜è¯­å¥éƒ½æ˜¯è°ƒç”¨ cmd/compile/internal/syntax.parser.appendGroup æ–¹æ³•è§£æçš„ã€‚

### èŠ‚ç‚¹ 
è¯­æ³•åˆ†æå™¨æœ€ç»ˆä¼šä½¿ç”¨ä¸åŒçš„ç»“æ„ä½“æ¥æ„å»ºæŠ½è±¡è¯­æ³•æ ‘ä¸­çš„èŠ‚ç‚¹ï¼Œå…¶ä¸­æ ¹èŠ‚ç‚¹ cmd/compile/internal/syntax.File åŒ…å«äº†å½“å‰æ–‡ä»¶çš„åŒ…åã€æ‰€æœ‰å£°æ˜ç»“æ„çš„åˆ—è¡¨å’Œæ–‡ä»¶çš„è¡Œæ•°ï¼š

    type File struct {
        Pragma   Pragma // äºå­˜å‚¨ä¸ç¼–è¯‘å™¨æŒ‡ä»¤ï¼ˆpragmaï¼‰ç›¸å…³çš„ä¿¡æ¯
        PkgName  *Name
        DeclList []Decl // å˜é‡ã€å¸¸é‡ã€ç±»å‹ã€å‡½æ•° ç­‰å£°æ˜
        Lines    uint
        node
    }

src/cmd/compile/internal/syntax/nodes.go æ–‡ä»¶ä¸­ä¹Ÿå®šä¹‰äº†å…¶ä»–èŠ‚ç‚¹çš„ç»“æ„ä½“ï¼Œå…¶ä¸­åŒ…å«å…¨éƒ¨å£°æ˜ç±»å‹çš„

    type (
        Decl interface {
            Node
            aDecl()
        }

        FuncDecl struct {
            Attr   map[string]bool
            Recv   *Field
            Name   *Name
            Type   *FuncType
            Body   *BlockStmt // å‡½æ•°ä½“å—
            Pragma Pragma
            decl
        }
    )

å…¶å®BlockStmt ç»“æ„ä½“å…¶å®æ˜¯`{List []Stmt, stmt}`, ä¹Ÿå°±æ˜¯cmd/compile/internal/syntax.Stmt æ¥å£. 

å®ç°è¯¥æ¥å£çš„ç±»å‹å…¶å®ä¹Ÿéå¸¸å¤šï¼Œæ€»å…±æœ‰ 14 ç§ä¸åŒç±»å‹çš„ syntax.Stmt å®ç°ï¼š

    // /src/cmd/compile/internal/syntax/nodes.go#L317
    BlockStmt, LabeledStmt
    IfStmtã€ForStmtã€SwitchStmt å’Œ SelectStmt
    CallStmt, ReturnStmt
    ExprStmt
    ...
